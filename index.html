<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <!--media pipe: 手の骨格取得や認識結果の描画に使用-->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <!--opencv.js: 手の傾きや中心位置を計算するために使用-->
    <script src="https://docs.opencv.org/3.4.1/opencv.js"></script>

    <!--MediaPipeやOpenCVでの処理を記述-->
    <script type="text/javascript">
        let canvasElement;
        let canvasCtx;  //キャンバスコンテキストを使って絵を描く
        let beam; //ライトセーバー的案画像
        let ell; //手の位置や傾きを楕円
        let ratio;  //親指の立ち具合を
        let isStandingThumb = false;  //親指が立ち上がっているかどうかのフラグ
        // let posThubs = [0, 0];  //[x座標, y座標]といったように格納していく
        let thumbPos_x = 0;
        let thumbPos_y = 0;
        let count = 0;
        const SE_wake = new Audio('./assets/wake.mp3');
        const SE_left = new Audio('./assets/left.mp3');
        const SE_right = new Audio('./assets/right.mp3');
        const BGM_SW = new Audio('./assets/STAR WARS theme.mp3');
        const BGM_DV = new Audio('./assets/Darth Vader.mp3');


        //初期化
        window.onload = function () {
            //画像の読み込み
            beam = document.getElementById('beam');
            //ビデオ要素の取得
            let videoElement = document.getElementById('input_video');
            //表示用のCanvasを取得
            canvasElement = document.getElementById('output_canvas');
            //Canvas描画に関する情報にアクセス
            canvasCtx = canvasElement.getContext('2d');
            //HandTrackingを使用するための関連ファイルの取得と初期化
            const hands = new Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }
            });
            //手の認識に関するオプション
            hands.setOptions({
                selfieMode: true,  //画像を左右反転
                maxNumHands: 1, //認識可能な手の最大数
                modelComplexity: 1,//精度に関する設定(0~1)
                minDetectionConfidence: 0.4,//手検出の信頼度 0〜1の値が帰ってきた時に幾つ以上の場合に手を判定するか
                minTrackingConfidence: 0.3,//手追跡の信頼度
                useCpuInference: false, //M1 MacのSafariの場合は1  crhomかfirefoxでやる
            });
            //結果を処理する関数を登録
            hands.onResults(recvResults);
            //カメラの初期化
            const camera = new Camera(videoElement, {
                onFrame: async () => {
                    //カメラの画像を用いて手の検出を実行
                    await hands.send({ image: videoElement });  //videoElementの映像をハンドトラッキング処理に渡す
                },
                width: 1280, height: 720  //画像サイズを設定
            });
            //カメラの動作開始
            camera.start();
        };
        //results = MediaPipeによる手の検出結果 を利用する
        function recvResults(results) {
            let width = results.image.width;  //イメージの元画像お大きさ
            let height = results.image.height;
            //画像のサイズとcanbasのサイズが異なる場合はサイズを調整
            if (width != canvasElement.width) { //最初は一致しないので
                //入力画像と同じサイズのcanvas(描画領域)を用意
                canvasElement.width = width;
                canvasElement.height = height;
            }
            //以下canvasへの描画に関する記述 saveで始まりrestoreでおわる
            canvasCtx.save();
            //(カメラで取得した)画像を表示
            canvasCtx.drawImage(results.image, 0, 0, width, height);

            //手を検出したならばtrue
            if (results.multiHandLandmarks) {
                //見つけた手の数だけ処理を繰り返す
                for (const landmarks of results.multiHandLandmarks) {
                    //骨格を描画(MediaPipeのライブラリ)  コメントアウトすれば表示せずに済む
                    drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, { color: '#040404', lineWidth: 1 });  //大きくすると線が太くなる
                    //関節を描画(MediaPipeのライブラリ)  コメントアウトすれば表示せずに済む
                    drawLandmarks(canvasCtx, landmarks, { color: '#000000', lineWidth: 1, radius: 2 });
                    cvFunction(landmarks, width, height);
                    drawLightSaber(); //自作関数
                    // wakeSaber_SE();
                }
            }
            canvasCtx.restore();
        }

        //手の中心や傾きを計算  関節の点群データlandmarksは画像の各幅全体を1と置き換えたパラメーターになっている。配列で０番目から20番目までの値が入っている
        function cvFunction(landmarks, width, height) {
            //手の関節を保持する配列
            let points = [];
            //手のひらや親指の付け根付近以外の関節を取得
            for (var i = 2; i < 21; i++) {  //手首の０、１は無視する
                //0~1で表現されたx,yを画像のサイズに変換
                points.push(landmarks[i].x * width);
                points.push(landmarks[i].y * height);
            }
            //点の集まりをOpenCVで扱えるデータフォーマットmatに変換         
            let mat = cv.matFromArray(points.length / 2, 1, cv.CV_32SC2, points);
            //点の集まりにフィットする楕円を計算 
            ell = cv.fitEllipse(mat);
            //メモリの解放(変数定義するとメモリを消費しているので不要になったら消す)
            mat.delete();

            //親指と人差し指までの距離
            let dx = (landmarks[7].x - landmarks[4].x) * width;
            let dy = (landmarks[7].y - landmarks[4].y) * height;
            let distance1 = Math.sqrt(dx * dx + dy * dy);
            //人差し指から小指までの距離
            dx = (landmarks[7].x - landmarks[19].x) * width;
            dy = (landmarks[7].y - landmarks[19].y) * height;
            let distance2 = Math.sqrt(dx * dx + dy * dy);
            //
            ratio = distance1 / distance2;
            //0.6:close, 1.3:sumb up 閉じる条件は少し甘めに0.9にする
            //0.9~1.3を0~1に正規化
            let close = 0.9;
            let up = 1.3;
            ratio = (Math.max(close, Math.min(up, ratio)) - close) / (up - close);//map(ratio,0.9,1.3,0,1,true);

            //指の立ち具合によってライトセイバーの起動音を出す。
            console.log(ratio);
            if (ratio >= 0.5) {
                wakeSaber_SE();
                isStandingThumb = true;
                thumbPos_x = landmarks[4].x;
                thumbPos_y = landmarks[4].y;
            } else if (ratio < 0.1) {  //閉じたらリセット
                count = 0;
                isStandingThumb = false;
            }

            //親指が立っている間に親指のxy座標を拾って、差分を取って速度を計算する
            if (isStandingThumb) {
                pastX = thumbPos_x;
                pastY = thumbPos_y;

                x = landmarks[4].x;
                y = landmarks[4].y;
                console.log(posThubs);
            } else {
                posThubs = [0, 0]
            }
            //親指が立っている状態の時、マイフレームの親指の位置を観測する
        }

        //ライトセイバーを表示
        function drawLightSaber() {  //画像、位置X、位置Y、横幅、縦幅
            //楕円の角度
            let angle = ell.angle;
            //ライトセイバーの向きを反転 openCVは第２.３象限でしか角度判定できない 
            if (angle < 90) { angle = angle - 180; }
            //デフォルトサイズを元画像の２倍くらいにしたい  ratioをかけることで親指の立ち具合で大きさが変わるようになった
            let mul = ratio * (ell.size.width * 1.5) / beam.width;
            //位置指定
            canvasCtx.translate(ell.center.x, ell.center.y);
            //角度指定
            canvasCtx.rotate(angle * Math.PI / 180.0); //openCVの角度は°でcanvasはラジアン
            //楕円を描画
            canvasCtx.beginPath();    //複数の点をつなぐ線を書くよの宣言
            canvasCtx.ellipse(0, 0,   //位置 楕円そのものでは位置指定せず、全体のオブジェクトに対してtranslate()で指定する
                ell.size.width / 2.0, ell.size.height / 2.0,  //半径
                0, 0, 2 * Math.PI);    //角度と表示の開始・終了
            canvasCtx.stroke();  //線で書くよ
            //デフォルトサイズに倍数をかける
            canvasCtx.scale(mul, mul);
            canvasCtx.drawImage(beam, -beam.width / 2.0, 0, beam.width, beam.height); //画像の位置をあらかじめx方向に半分ずらす
        }

        // 効果音
        //ライトセイバー起動時の一回のみ
        function wakeSaber_SE() {
            if (count == 0) {
                console.log("SEスタート");
                SE_wake.play();
                count++;
                console.log(count);
            } else {
            }
            // SE_wake.pause();
        }
    </script>
</head>

<!-- 描画領域 -->

<body>
    <!-- videoタグでアクセス Webカメラの映像を取得(不可視に設定) -->
    <video id="input_video" style="position:absolute; display:none;"></video>
    <!-- ライトセーバー的な画像(不可視に設定) display:none; -->
    <img id="beam" src="./assets/beam.png" style="position:absolute; display:none; ">
    <!-- カメラ画像とての認証結果を合成して表示 -->
    <canvas id="output_canvas" style="position:absolute;"></canvas>
</body>

</html>